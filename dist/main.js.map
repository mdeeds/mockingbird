{"version":3,"sources":["webpack:///./src/Log.js","webpack:///./src/audio.js","webpack:///./src/index.js","webpack:///./src/loop.js","webpack:///./src/loopManager.js","webpack:///./src/loopViz.js","webpack:///./src/sampleSource.js","webpack:///webpack/bootstrap","webpack:///webpack/startup"],"names":[],"mappings":";;;;;;;AAAa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,WAAW;AACX;AACA;AACA;AACA,uBAAuB,GAAG,GAAG,QAAQ;AACrC;AACA;AACA,WAAW;AACX,+B;;;;;;;ACVa;AACb;AACA,2BAA2B,+DAA+D,gBAAgB,EAAE,EAAE;AAC9G;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,qFAAqF;AACpH;AACA,KAAK;AACL;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,iC;;;;;;;AC1Ca;AACb;AACA,2BAA2B,+DAA+D,gBAAgB,EAAE,EAAE;AAC9G;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,qFAAqF;AACpH;AACA,KAAK;AACL;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,gBAAgB,mBAAO,CAAC,GAAS;AACjC,eAAe,mBAAO,CAAC,GAAQ;AAC/B,sBAAsB,mBAAO,CAAC,EAAe;AAC7C,uBAAuB,mBAAO,CAAC,GAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,0CAA0C;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,uBAAuB;AAClE;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,iC;;;;;;;AC3Ca;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,YAAY;AACZ,cAAc,mBAAO,CAAC,GAAO;AAC7B,kBAAkB,mBAAO,CAAC,EAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uBAAuB,uBAAuB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uBAAuB,uBAAuB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,IAAI;AAChC;AACA;AACA,gDAAgD,aAAa,EAAE;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,kDAAkD,oBAAoB,EAAE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,gC;;;;;;;AC3Oa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,mBAAmB;AACnB,cAAc,mBAAO,CAAC,GAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,YAAY,yBAAyB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iBAAiB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uBAAuB;AACrD,iCAAiC,gCAAgC;AACjE,iCAAiC,mBAAmB;AACpD,qCAAqC,eAAe,EAAE;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iBAAiB,EAAE;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB,EAAE;AAC7C;AACA;AACA,mBAAmB;AACnB;AACA,uC;;;;;;;AC9Ia;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,eAAe;AACf;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,mC;;;;;;;AClDa;AACb;AACA,2BAA2B,+DAA+D,gBAAgB,EAAE,EAAE;AAC9G;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,qFAAqF;AACpH;AACA,KAAK;AACL;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,UAAU;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,0BAA0B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,oCAAoC,EAAE;AAChF;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,sCAAsC,qBAAqB;AAC3D;AACA;AACA,uDAAuD,qBAAqB;AAC5E;AACA;AACA;AACA;AACA,oBAAoB;AACpB,wC;;;;;;UCjJA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;UCrBA;UACA;UACA;UACA","file":"main.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Log = void 0;\nclass Log {\n    static info(message) {\n        const ts = (performance.now() / 1000).toFixed(3);\n        console.log(`${ts} ${message}`);\n    }\n}\nexports.Log = Log;\n//# sourceMappingURL=Log.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Audio = void 0;\nclass Audio {\n    constructor(context) {\n        this.audioCtx = context;\n    }\n    static make() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const ctx = yield Audio.getAudioContext();\n            return new Promise((resolve, reject) => {\n                resolve(new Audio(ctx));\n            });\n        });\n    }\n    static getAudioContext() {\n        return new Promise((resolve, reject) => {\n            const context = new window.AudioContext();\n            if (context.state === 'running') {\n                resolve(context);\n            }\n            else {\n                setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n                    resolve(yield Audio.getAudioContext());\n                }), 500);\n            }\n        });\n    }\n    static HzFromNote(note) {\n        return 440 * Math.pow(2, (note - 69) / 12);\n    }\n}\nexports.Audio = Audio;\n//# sourceMappingURL=audio.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst audio_1 = require(\"./audio\");\nconst loop_1 = require(\"./loop\");\nconst loopManager_1 = require(\"./loopManager\");\nconst sampleSource_1 = require(\"./sampleSource\");\nfunction go() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const body = document.getElementsByTagName('body')[0];\n        const mm = document.createElement('div');\n        const report = function () {\n            const mem = window.performance['memory'];\n            mm.innerText = `${(mem.usedJSHeapSize / 1000000).toFixed(3)}MB`;\n            setTimeout(report, 100);\n        };\n        body.appendChild(mm);\n        report();\n        const a = yield audio_1.Audio.make();\n        const s = yield sampleSource_1.SampleSource.make(a);\n        let l = new loop_1.Loop(s);\n        let recentlyCompletedLoop = null;\n        const lm = new loopManager_1.LoopManager(a, l);\n        let changeRate = 0;\n        body.addEventListener('keydown', (ev) => {\n            switch (ev.code) {\n                case 'Space':\n                    console.log(`Space @ ${a.audioCtx.currentTime}`);\n                    lm.nextMode();\n                    break;\n            }\n        });\n    });\n}\ngo();\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Loop = void 0;\nconst Log_1 = require(\"./Log\");\nconst loopViz_1 = require(\"./loopViz\");\nclass Loop {\n    constructor(sampleSource) {\n        // State data\n        this.recordUntil = 0;\n        this.isFinalized = false;\n        this.isMuted = false;\n        this.sampleLengthS = 0;\n        this.sampleList = [];\n        // Buffer data\n        this.audioBuffer = null;\n        this.source = null;\n        this.headerS = undefined;\n        this.bodyS = undefined;\n        this.offsetS = 0.0;\n        this.bpm = 90;\n        this.sampleSource = sampleSource;\n        this.audioCtx = sampleSource.audioCtx;\n        this.sampleSource.addListener(this, (samples, endTimeS) => {\n            this.handleSamples(samples, endTimeS);\n        });\n    }\n    nextLoop() {\n        const result = new Loop(this.sampleSource);\n        result.sampleStartS = this.sampleStartS;\n        for (const s of this.sampleList) {\n            result.rollSamples(s);\n        }\n        return result;\n    }\n    getBodyS() {\n        if (!this.bodyS) {\n            throw new Error(\"Loop is not complete.\");\n        }\n        return this.bodyS;\n    }\n    getPlayLengthS() {\n        if (!this.bodyS) {\n            throw new Error(\"Loop is not complete.\");\n        }\n        return this.bodyS + Loop.maxFooterS;\n    }\n    adjustStartPoint(deltaS) {\n        this.headerS += deltaS;\n        this.offsetS += deltaS;\n        this.renderCanvas();\n    }\n    startRecording(timestamp) {\n        Log_1.Log.info(`Start recording; sample list length: ${this.sampleList.length}`);\n        if (this.recordUntil > 0) {\n            throw new Error(\"Already recording.\");\n        }\n        this.recordUntil = Infinity;\n        this.recordingStartS = timestamp;\n    }\n    fillFromSamples(sampleIndex) {\n        const headerStartS = this.recordingStartS - Loop.maxHeaderS;\n        // Offset into buffer measured in sample points to where this sample starts\n        let bufferStart = Math.round((this.sampleStartS - headerStartS) * this.audioCtx.sampleRate);\n        for (let i = 0; i < sampleIndex; ++i) {\n            bufferStart += this.sampleList[i].length;\n        }\n        const buffer = this.audioBuffer.getChannelData(0);\n        const sample = this.sampleList[sampleIndex];\n        let numFilled = 0;\n        for (let i = 0; i < sample.length; ++i) {\n            const targetOffset = i + bufferStart;\n            if (targetOffset >= 0 && targetOffset < buffer.length) {\n                buffer[targetOffset] = sample[i];\n                ++numFilled;\n            }\n        }\n    }\n    stopRecording(timestamp) {\n        Log_1.Log.info(`Stop recording; sample list length: ${this.sampleList.length}`);\n        if (this.isFinalized) {\n            throw new Error(\"Already finalized\");\n        }\n        this.recordUntil = timestamp + Loop.maxFooterS;\n        // The buffer for the AudioBufferSourceNode can be modified\n        // after the recording has stopped.  So, at this point we just\n        // create the entire audio buffer and dump the tail samples into it as\n        // they arrive. \n        this.bodyS = timestamp - this.recordingStartS;\n        this.headerS = Loop.maxHeaderS;\n        const loopLengthS = this.bodyS + Loop.maxHeaderS + Loop.maxFooterS;\n        const loopLengthSamples = loopLengthS * this.audioCtx.sampleRate;\n        this.audioBuffer = this.audioCtx.createBuffer(1, loopLengthSamples, this.audioCtx.sampleRate);\n        for (let i = 0; i < this.sampleList.length; ++i) {\n            this.fillFromSamples(i);\n        }\n    }\n    startSample(timestamp) {\n        if (this.isMuted) {\n            Log_1.Log.info(`Muted.`);\n            return;\n        }\n        const currentTime = this.audioCtx.currentTime;\n        this.source = this.audioCtx.createBufferSource();\n        this.source.buffer = this.audioBuffer;\n        this.source.connect(this.audioCtx.destination);\n        if (currentTime > timestamp) {\n            // We are already late.\n            const lateS = currentTime - timestamp;\n            this.source.start(currentTime, currentTime - timestamp);\n        }\n        else {\n            this.source.start(timestamp);\n        }\n        this.source.stop(timestamp + this.bodyS);\n    }\n    finalize() {\n        Log_1.Log.info(\"Finalize\");\n        for (let i = 0; i < this.sampleList.length; ++i) {\n            this.fillFromSamples(i);\n        }\n        // this.renderCanvas();\n        this.sampleSource.removeListener(this);\n        this.isFinalized = true;\n    }\n    maxOfArray(a) {\n        let m = a[0];\n        for (const x of a) {\n            m = Math.max(m, x);\n        }\n        return m;\n    }\n    rollSamples(samples) {\n        // We have not started recording.  Keep a rolling buffer.\n        const samplesLengthS = samples.length / this.audioCtx.sampleRate;\n        this.sampleList.push(samples.slice());\n        this.sampleLengthS += samplesLengthS;\n        while (true) {\n            const firstBufferLengthS = this.sampleList[0].length / this.audioCtx.sampleRate;\n            if (this.sampleLengthS - firstBufferLengthS < Loop.maxHeaderS) {\n                break;\n            }\n            this.sampleList.shift();\n            this.sampleLengthS -= firstBufferLengthS;\n            this.sampleStartS += firstBufferLengthS;\n        }\n    }\n    handleSamples(samples, endTimeS) {\n        const samplesLengthS = samples.length / this.audioCtx.sampleRate;\n        if (this.sampleList.length === 0) {\n            this.sampleStartS = endTimeS - samplesLengthS;\n        }\n        if (this.recordUntil === 0) {\n            this.rollSamples(samples);\n        }\n        else if (endTimeS < this.recordUntil) {\n            // Recording has started.  Fill the samples as they arrive.\n            this.sampleList.push(samples);\n            this.sampleLengthS += samplesLengthS;\n            if (this.audioBuffer) {\n                this.fillFromSamples(this.sampleList.length - 1);\n            }\n        }\n        else if (!this.isFinalized) {\n            this.sampleList.push(samples);\n            this.sampleLengthS += samplesLengthS;\n            if (this.audioBuffer) {\n                this.fillFromSamples(this.sampleList.length - 1);\n            }\n            this.finalize();\n        }\n    }\n    renderCanvas() {\n        if (!this.canvas) {\n            throw new Error('Render called before we have a canvas.');\n        }\n        loopViz_1.LoopViz.render(this.audioBuffer.getChannelData(0), this.audioCtx.sampleRate, this.bpm, this.headerS, this.canvas);\n        const ctx = this.canvas.getContext('2d');\n        ctx.beginPath();\n        ctx.fillStyle = 'black';\n        ctx.fillText(`${(this.offsetS * 1000).toFixed(0)}ms`, 5, 20);\n    }\n    handleKey(ev) {\n        switch (ev.code) {\n            case 'ArrowRight':\n                if (Loop.changeRate > 0) {\n                    Loop.changeRate = Math.min(Loop.changeRate * 2, 0.05);\n                }\n                else {\n                    Loop.changeRate *= -0.5;\n                }\n                this.adjustStartPoint(Loop.changeRate);\n                break;\n            case 'ArrowLeft':\n                if (Loop.changeRate < 0) {\n                    Loop.changeRate = Math.max(Loop.changeRate * 2, -0.05);\n                }\n                else {\n                    Loop.changeRate *= -0.5;\n                }\n                this.adjustStartPoint(Loop.changeRate);\n                break;\n        }\n    }\n    addCanvas(bpm) {\n        this.bpm = bpm;\n        console.log(`BPM: ${bpm}`);\n        const body = document.getElementsByTagName('body')[0];\n        const span = document.createElement('span');\n        // div.addEventListener('click', () => { div.focus(); });\n        span.addEventListener('touchstart', () => {\n            span.focus();\n            this.isMuted = !this.isMuted;\n            if (this.isMuted) {\n                span.classList.add('muted');\n            }\n            else {\n                span.classList.remove('muted');\n            }\n        });\n        span.addEventListener('keydown', (ev) => { this.handleKey(ev); });\n        span.classList.add('loopContainer');\n        span.tabIndex = 0;\n        body.appendChild(span);\n        this.canvas = document.createElement('canvas');\n        this.canvas.width = 100;\n        this.canvas.height = 100;\n        span.appendChild(this.canvas);\n        span.focus();\n        this.renderCanvas();\n    }\n}\nexports.Loop = Loop;\nLoop.maxHeaderS = 0.5;\nLoop.maxFooterS = 0.5;\nLoop.changeRate = 0.001;\n//# sourceMappingURL=loop.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LoopManager = void 0;\nconst Log_1 = require(\"./Log\");\nclass PlayingLoop {\n    constructor(loop, startTimeS) {\n        this.loop = loop;\n        this.startTimeS = startTimeS;\n    }\n}\nclass LoopManager {\n    constructor(audio, firstLoop) {\n        this.loops = [];\n        this.playingLoops = [];\n        this.loopMode = 'waiting';\n        this.audio = audio;\n        this.curentLoop = firstLoop;\n        this.audioCtx = audio.audioCtx;\n        this.canvas = document.createElement('canvas');\n        this.canvas.width = 100;\n        this.canvas.height = 100;\n        const body = document.getElementsByTagName('body')[0];\n        body.appendChild(this.canvas);\n    }\n    nextMode() {\n        switch (this.loopMode) {\n            case 'waiting':\n                Log_1.Log.info('Start.');\n                this.curentLoop.startRecording(this.audioCtx.currentTime);\n                this.loopMode = 'initial';\n                break;\n            case 'initial':\n                const nowTime = this.audioCtx.currentTime;\n                Log_1.Log.info('Captured.');\n                this.curentLoop.stopRecording(nowTime);\n                this.addFirstLoop(this.curentLoop);\n                this.nextLoopStartS = nowTime + this.curentLoop.getBodyS();\n                this.curentLoop.addCanvas(60 / this.beatLengthS);\n                this.curentLoop = this.curentLoop.nextLoop();\n                this.curentLoop.startRecording(nowTime);\n                this.loopMode = 'play';\n                break;\n            case 'play':\n                this.loopMode = 'overdub';\n                break;\n            case 'overdub':\n                this.loopMode = 'play';\n                break;\n        }\n    }\n    addFirstLoop(loop) {\n        const nowTimeS = this.audioCtx.currentTime;\n        if (this.loops.length > 0) {\n            throw new Error('Already started playing.');\n        }\n        Log_1.Log.info(`Adding loop; playing: ${this.playingLoops.length}`);\n        this.setTempo(loop.getBodyS());\n        this.startTimeS = nowTimeS;\n        this.scheduledThroughS = nowTimeS;\n        loop.startSample(this.startTimeS);\n        this.schedule();\n        this.render();\n        this.loops.push(loop);\n    }\n    setTempo(durationS) {\n        this.loopLengthS = durationS;\n        let beatLengthS = durationS;\n        while (beatLengthS < 0.5) {\n            beatLengthS *= 2;\n        }\n        while (beatLengthS > 1.0) {\n            beatLengthS /= 2;\n        }\n        this.beatLengthS = beatLengthS;\n        Log_1.Log.info(`Beats per minute: ${60 / beatLengthS}`);\n    }\n    render() {\n        const elapsed = this.audioCtx.currentTime - this.startTimeS;\n        const currentBeatFrac = (elapsed / this.beatLengthS) % 1.0;\n        const currentBeatInt = Math.trunc(elapsed / this.beatLengthS);\n        const currentMeasureNumber = Math.trunc(currentBeatInt / 4);\n        const currentBeat = currentBeatInt % 4 + 1;\n        const isOnBeat = currentBeatFrac < 0.5;\n        const ctx = this.canvas.getContext('2d');\n        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        ctx.lineWidth = 8;\n        if (this.loopMode == 'overdub') {\n            ctx.strokeStyle = '#933';\n        }\n        else if (this.loopMode == 'play') {\n            ctx.strokeStyle = '#393';\n        }\n        ctx.beginPath();\n        ctx.arc(50, 50, 45, -Math.PI, Math.PI);\n        ctx.stroke();\n        ctx.strokeStyle = '#393';\n        const start = -Math.PI / 2;\n        ctx.beginPath();\n        ctx.arc(50, 50, 20, start, start + Math.PI * 2 * currentBeatFrac);\n        ctx.stroke();\n        ctx.fillStyle = 'black';\n        ctx.fillText(`beat: ${currentBeat.toFixed(0)}`, 20, 20);\n        ctx.fillText(`measure: ${currentMeasureNumber.toFixed(0)}`, 20, 40);\n        ctx.fillText(`elapsed: ${elapsed.toFixed(3)}`, 20, 60);\n        requestAnimationFrame(() => { this.render(); });\n    }\n    // Called at beginning of each loop from Schedule.\n    // Adds current loop to loops if in overdub mode.\n    // Starts a new loop recording.\n    onTopOfLoop(audioTimstampS) {\n        Log_1.Log.info('Top of loop...');\n        this.curentLoop.stopRecording(audioTimstampS);\n        if (this.loopMode === 'overdub') {\n            this.loops.push(this.curentLoop);\n            this.curentLoop.addCanvas(60 / this.beatLengthS);\n            this.loopMode = 'play';\n        }\n        this.curentLoop = this.curentLoop.nextLoop();\n        this.curentLoop.startRecording(audioTimstampS);\n    }\n    schedule() {\n        if (this.audioCtx.currentTime + LoopManager.scheduleAheadS <\n            this.scheduledThroughS) {\n            // Nothing to do.  We are scheduled up through our schedule ahead buffer.\n            setTimeout(() => { this.schedule(); }, 100);\n            return;\n        }\n        const nextScheduleThroughS = this.scheduledThroughS + LoopManager.scheduleAheadS;\n        if (this.audioCtx.currentTime + LoopManager.scheduleAheadS >\n            this.nextLoopStartS) {\n            this.onTopOfLoop(this.nextLoopStartS);\n            for (const l of this.loops) {\n                l.startSample(this.nextLoopStartS);\n            }\n            this.nextLoopStartS += this.loopLengthS;\n        }\n        this.scheduledThroughS = nextScheduleThroughS;\n        setTimeout(() => { this.schedule(); }, 100);\n    }\n}\nexports.LoopManager = LoopManager;\nLoopManager.scheduleAheadS = 0.5;\n//# sourceMappingURL=loopManager.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LoopViz = void 0;\nclass LoopViz {\n    static getPeaks(buffer, samplesPerPeak, offset) {\n        const result = [];\n        let m = 0;\n        for (let i = offset; i < buffer.length; ++i) {\n            result.push(m);\n            const nextI = Math.min(buffer.length, i + samplesPerPeak);\n            m = 0;\n            while (i < nextI) {\n                m = Math.max(m, Math.pow(Math.abs(buffer[i]), 0.5));\n                ++i;\n            }\n        }\n        return result;\n    }\n    static render(samples, sampleRate, bpm, headerS, canvas) {\n        console.log('render');\n        const peaksPerSecond = 200;\n        const secondsPerPeak = 1 / peaksPerSecond;\n        const samplesPerPeak = sampleRate * secondsPerPeak;\n        const radiansPerBeat = Math.PI / 2;\n        const secondsPerRadian = (60 / bpm) / radiansPerBeat;\n        const peaksPerRadian = peaksPerSecond * secondsPerRadian;\n        const radiansPerPeak = 1 / peaksPerRadian;\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'blue';\n        ctx.strokeStyle = 'white';\n        ctx.lineWidth = 0.5;\n        const peaks = this.getPeaks(samples, samplesPerPeak, Math.round(headerS * sampleRate));\n        ctx.beginPath();\n        const cx = canvas.width / 2;\n        const cy = canvas.height / 2;\n        const r = Math.min(cx, cy);\n        ctx.moveTo(cx, cy);\n        let t = Math.PI / 2; // Start downward.\n        for (let x = 0; x < peaks.length; ++x) {\n            ctx.lineTo(cx + Math.cos(t) * r * peaks[x], cy + Math.sin(t) * r * peaks[x]);\n            t += radiansPerPeak;\n        }\n        console.log(t);\n        ctx.lineTo(cx, cy);\n        ctx.fill();\n        ctx.stroke();\n    }\n}\nexports.LoopViz = LoopViz;\n//# sourceMappingURL=loopViz.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SampleSource = void 0;\nclass SampleSource {\n    constructor(audio) {\n        this.firstChunkSize = 0;\n        this.firstChunk = null;\n        this.listeners = new Map();\n        this.audio = audio;\n        this.audioCtx = audio.audioCtx;\n    }\n    static make(audio) {\n        const self = new SampleSource(audio);\n        console.log(\"Attempting to initialize.\");\n        console.assert(!!navigator.mediaDevices.getUserMedia);\n        var constraints = {\n            audio: true,\n            video: false,\n            echoCancellation: false,\n            noiseSuppersion: false,\n        };\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            const stream = yield navigator.mediaDevices.getUserMedia(constraints);\n            self.handleStream(stream, resolve);\n        }));\n    }\n    addListener(source, callback) {\n        this.listeners.set(source, callback);\n    }\n    removeListener(source) {\n        this.listeners.delete(source);\n    }\n    setUpAnalyser(mediaSource) {\n        const body = document.getElementsByTagName('body')[0];\n        const canvas = document.createElement('canvas');\n        canvas.width = 100;\n        canvas.height = 100;\n        body.appendChild(canvas);\n        const ctx = canvas.getContext('2d');\n        const analyser = this.audioCtx.createAnalyser();\n        analyser.fftSize = 2048;\n        this.mediaSource.connect(analyser);\n        const dataArray = new Float32Array(analyser.frequencyBinCount);\n        const render = () => {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            analyser.getFloatTimeDomainData(dataArray);\n            let m = 0;\n            let s = 0;\n            for (let i = 0; i < dataArray.length; ++i) {\n                const v = Math.pow(Math.abs(dataArray[i]), 0.3);\n                m = Math.max(m, v);\n                s += v;\n            }\n            const thetaMax = Math.PI * m;\n            const thetaMean = Math.PI * s / dataArray.length;\n            const start = Math.PI / 2;\n            ctx.beginPath();\n            ctx.lineCap = 'round';\n            ctx.strokeStyle = '#44f';\n            ctx.lineWidth = 25;\n            ctx.arc(50, 50, 30, start - thetaMean, start + thetaMean);\n            ctx.stroke();\n            ctx.beginPath();\n            ctx.strokeStyle = '#f48';\n            ctx.lineWidth = 5;\n            ctx.arc(50, 50, 30, start - thetaMax, start + thetaMax);\n            ctx.stroke();\n            requestAnimationFrame(render);\n        };\n        requestAnimationFrame(render);\n    }\n    handleStream(stream, resolve) {\n        this.mediaSource = this.audioCtx.createMediaStreamSource(stream);\n        this.setUpAnalyser(this.mediaSource);\n        var options = {\n            mimeType: \"audio/webm;codecs=pcm\",\n        };\n        if (this.mediaRecorder) {\n            this.mediaRecorder.stop();\n        }\n        this.mediaRecorder = new MediaRecorder(stream, options);\n        this.mediaRecorder.onstart = (e) => {\n            console.log(`Media stream start ${stream.id}`);\n        };\n        this.mediaRecorder.onstop = (e) => {\n            this.decodeChunk(e.data);\n            this.mediaRecorder = null;\n        };\n        this.mediaRecorder.ondataavailable = (e) => {\n            this.decodeChunk(e.data);\n        };\n        this.mediaRecorder.start(/*timeslice=*/ 500 /*ms*/);\n        console.log(`Initialized @ ${this.audioCtx.currentTime}`);\n        resolve(this);\n    }\n    maxOfArray(a) {\n        let m = a[0];\n        for (const x of a) {\n            m = Math.max(m, x);\n        }\n        return m;\n    }\n    decodeChunk(chunk) {\n        let chunkEndTime = this.audioCtx.currentTime;\n        let fileReader = new FileReader();\n        fileReader.onloadend = () => {\n            const encodedData = fileReader.result;\n            // console.log(\"Encoded length: \" + encodedData.byteLength);\n            this.audioCtx.decodeAudioData(encodedData, (decodedSamples) => {\n                // TODO: Consider supporting stereo or more channels.\n                let newSamples = decodedSamples.getChannelData(0)\n                    .slice(this.firstChunkSize, decodedSamples.length);\n                if (newSamples.length > 0) {\n                    for (const listener of this.listeners.values()) {\n                        setTimeout(() => { listener(newSamples, chunkEndTime); }, 0);\n                    }\n                }\n                if (this.firstChunkSize == 0) {\n                    this.firstChunkSize = decodedSamples.length;\n                }\n            }, (er) => {\n                console.error(er);\n            });\n        };\n        let blob;\n        if (!this.firstChunk) {\n            this.firstChunk = chunk;\n            blob = new Blob([chunk], { 'type': chunk.type });\n        }\n        else {\n            blob = new Blob([this.firstChunk, chunk], { 'type': chunk.type });\n        }\n        fileReader.readAsArrayBuffer(blob);\n    }\n}\nexports.SampleSource = SampleSource;\n//# sourceMappingURL=sampleSource.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module\n// This entry module is referenced by other modules so it can't be inlined\n__webpack_require__(138);\n"],"sourceRoot":""}